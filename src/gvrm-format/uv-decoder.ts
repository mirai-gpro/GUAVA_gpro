// src/gvrm-format/uv-decoder.ts
// GUAVA UV Decoder - WebGL GPUå°‚ç”¨ç‰ˆï¼ˆäº‹å‰è¨ˆç®—ãƒãƒƒãƒ”ãƒ³ã‚°ä¸è¦ï¼‰
// ä¿®æ­£ç‰ˆ: å…¥åŠ›æ¤œè¨¼ãƒ»CHWã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ãƒ»ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–

import * as ort from 'onnxruntime-web/wasm';
import type { UVTriangleMapping } from './webgl-uv-rasterizer';

/**
 * UV Gaussians ã®å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
 */
export interface UVGaussianOutput {
  uvCount: number;
  
  // ãƒ¢ãƒ‡ãƒ«å‡ºåŠ›ï¼ˆUVç©ºé–“ï¼‰
  localPositions: Float32Array;    // [N, 3] Î”Î¼ï¼ˆä¸‰è§’å½¢å†…ãƒ­ãƒ¼ã‚«ãƒ«ä½ç½®ï¼‰
  opacity: Float32Array;           // [N] Î±ï¼ˆä¸é€æ˜åº¦ï¼‰
  scale: Float32Array;             // [N, 3] sï¼ˆã‚¹ã‚±ãƒ¼ãƒ« x,y,zï¼‰
  rotation: Float32Array;          // [N, 4] rï¼ˆå›è»¢ quaternionï¼‰
  latent32ch: Float32Array;        // [N, 32] cï¼ˆ32æ¬¡å…ƒç‰¹å¾´ï¼‰
  
  // ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ï¼ˆä¸‰è§’å½¢ã¸ã®å¯¾å¿œä»˜ã‘ï¼‰
  triangleIndices: Uint32Array;    // [N] å„UV GaussianãŒå±ã™ã‚‹ä¸‰è§’å½¢
  barycentricCoords: Float32Array; // [N, 3] é‡å¿ƒåº§æ¨™
  uvCoords: Float32Array;          // [N, 2] UVåº§æ¨™ï¼ˆå‚ç…§ç”¨ï¼‰
}

/**
 * é…åˆ—æ¤œè¨¼çµæœ
 */
interface ArrayValidation {
  length: number;
  nanCount: number;
  infCount: number;
  zeroCount: number;
  nanRatio: number;
  zeroRatio: number;
  min: number;
  max: number;
}

/**
 * UV Decoderï¼ˆWebGL GPUå°‚ç”¨ç‰ˆï¼‰
 * 
 * å¤‰æ›´ç‚¹:
 * - äº‹å‰è¨ˆç®—ã•ã‚ŒãŸãƒãƒƒãƒ”ãƒ³ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚’å‰Šé™¤
 * - WebGLãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‹ã‚‰ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ç›´æ¥å—ã‘å–ã‚‹
 * - åˆæœŸåŒ–ãŒé«˜é€ŸåŒ–
 * - å…¥åŠ›/å‡ºåŠ›ã®æ¤œè¨¼ã‚’å¼·åŒ–
 * - CHWå½¢å¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ã‚’æ˜ç¤ºåŒ–
 */
export class UVDecoder {
  private session: ort.InferenceSession | null = null;
  private mapping: UVTriangleMapping | null = null;
  
  /**
   * åˆæœŸåŒ–ï¼ˆäº‹å‰è¨ˆç®—ãƒãƒƒãƒ”ãƒ³ã‚°ä¸è¦ï¼‰
   */
  async init(basePath: string): Promise<void> {
    console.log('[UVDecoder] Initializing (WebGL GPU mode)...');
    
    try {
      // ONNX Runtime ã®è¨­å®š
      ort.env.wasm.numThreads = 1;
      ort.env.wasm.simd = true;
      ort.env.wasm.proxy = false;
      
      // iOSå¯¾å¿œã®è¨­å®š
      if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = false;
      }
      
      // ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
      const modelPath = `${basePath}/uv_point_decoder.onnx`;
      console.log('[UVDecoder] Loading model from:', modelPath);
      
      this.session = await ort.InferenceSession.create(modelPath, {
        executionProviders: ['wasm'],
        graphOptimizationLevel: 'all'
      });
      
      console.log('[UVDecoder] âœ… Model loaded');
      console.log('[UVDecoder] ğŸ” Input names:', this.session.inputNames);
      console.log('[UVDecoder] ğŸ” Output names:', this.session.outputNames);
      console.log('[UVDecoder] âš¡ UV Triangle Mapping will be generated by WebGL GPU');
      console.log('[UVDecoder] âœ… Initialization complete');
      
    } catch (error) {
      console.error('[UVDecoder] âŒ Initialization failed:', error);
      throw error;
    }
  }
  
  /**
   * ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¨­å®šï¼ˆWebGLãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‹ã‚‰å—ã‘å–ã‚‹ï¼‰
   */
  setMapping(mapping: UVTriangleMapping): void {
    this.mapping = mapping;
    console.log('[UVDecoder] Mapping set:', {
      resolution: `${mapping.width}Ã—${mapping.height}`,
      validPixels: mapping.numValid.toLocaleString(),
      coverage: `${(mapping.numValid / (mapping.width * mapping.height) * 100).toFixed(1)}%`
    });
  }
  
  /**
   * UV Gaussians ã‚’ç”Ÿæˆï¼ˆãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å¼•æ•°ã§å—ã‘å–ã‚‹ç‰ˆï¼‰
   * 
   * @param uvFeatureMap UVç©ºé–“ã®ç‰¹å¾´ãƒãƒƒãƒ— [155, H, W]
   * @param uvWidth UVå¹…
   * @param uvHeight UVé«˜ã•
   * @param mapping WebGLãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã§ç”Ÿæˆã•ã‚ŒãŸãƒãƒƒãƒ”ãƒ³ã‚°
   * @returns UV Gaussians ã®å±æ€§ãƒ‡ãƒ¼ã‚¿
   */
  async generate(
    uvFeatureMap: Float32Array,
    uvWidth: number,
    uvHeight: number,
    mapping?: UVTriangleMapping
  ): Promise<UVGaussianOutput> {
    if (!this.session) {
      throw new Error('UVDecoder not initialized');
    }
    
    // ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¨­å®šï¼ˆå¼•æ•°ã¾ãŸã¯äº‹å‰è¨­å®šï¼‰
    if (mapping) {
      this.setMapping(mapping);
    }
    
    if (!this.mapping) {
      throw new Error('UV Triangle Mapping not provided. Use setMapping() or pass as argument.');
    }
    
    console.log('[UVDecoder] Generating UV Gaussians...');
    
    // âœ… å…¥åŠ›æ¤œè¨¼ã‚’å¼·åŒ–
    const expectedSize = 155 * uvWidth * uvHeight;
    
    console.log('[UVDecoder] Input validation:', {
      uvFeatureMapSize: uvFeatureMap.length.toLocaleString(),
      expectedSize: expectedSize.toLocaleString(),
      uvResolution: `${uvWidth}Ã—${uvHeight}`,
      match: uvFeatureMap.length === expectedSize ? 'âœ…' : 'âŒ'
    });
    
    // âœ… ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
    if (uvFeatureMap.length !== expectedSize) {
      throw new Error(
        `UV feature map size mismatch: expected ${expectedSize}, got ${uvFeatureMap.length}`
      );
    }
    
    // âœ… NaN/Inf/Zero ãƒã‚§ãƒƒã‚¯ï¼ˆã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
    const sampleSize = Math.min(10000, uvFeatureMap.length);
    let nanCount = 0;
    let infCount = 0;
    let zeroCount = 0;
    
    for (let i = 0; i < sampleSize; i++) {
      const v = uvFeatureMap[i];
      if (isNaN(v)) nanCount++;
      else if (!isFinite(v)) infCount++;
      else if (v === 0) zeroCount++;
    }
    
    const nanRatio = nanCount / sampleSize;
    const zeroRatio = zeroCount / sampleSize;
    
    console.log('[UVDecoder] Input quality check (first 10k values):', {
      nanCount,
      infCount,
      zeroCount,
      validCount: sampleSize - nanCount - infCount - zeroCount,
      nanRatio: (nanRatio * 100).toFixed(1) + '%',
      zeroRatio: (zeroRatio * 100).toFixed(1) + '%'
    });
    
    if (nanRatio > 0.5) {
      console.error('[UVDecoder] âŒ Input contains >50% NaN values!');
      console.error('[UVDecoder] This indicates Inverse Texture Mapping failed.');
      throw new Error('Invalid UV feature map: too many NaN values');
    }
    
    if (infCount > 0) {
      console.error('[UVDecoder] âŒ Input contains Infinity values!');
      throw new Error('Invalid UV feature map: contains Inf values');
    }
    
    if (zeroRatio > 0.9) {
      console.warn('[UVDecoder] âš ï¸  Input is mostly zeros (>90%)!');
      console.warn('[UVDecoder] Output quality may be poor.');
    }
    
    try {
      // å…¥åŠ›ãƒ†ãƒ³ã‚½ãƒ«ã‚’ä½œæˆ [1, 155, H, W]
      const inputTensor = new ort.Tensor(
        'float32',
        uvFeatureMap,
        [1, 155, uvHeight, uvWidth]
      );
      
      const feeds = {
        'uv_features': inputTensor
      };
      
      // æ¨è«–å®Ÿè¡Œ
      console.log('[UVDecoder] Running inference...');
      const startTime = performance.now();
      
      const outputs = await this.session.run(feeds);
      
      const inferenceTime = performance.now() - startTime;
      console.log('[UVDecoder] âœ… Inference complete:', `${inferenceTime.toFixed(1)}ms`);
      
      // âœ… åˆ©ç”¨å¯èƒ½ãªå‡ºåŠ›åã‚’ç¢ºèª
      const availableOutputs = Object.keys(outputs);
      console.log('[UVDecoder] Available outputs:', availableOutputs);
      
      // å‡ºåŠ›ã‚’å–å¾—
      const localPos = this.extractOutput(outputs, ['local_pos'], 3 * uvHeight * uvWidth);
      const opacity = this.extractOutput(outputs, ['opacity'], uvHeight * uvWidth);
      const scale = this.extractOutput(outputs, ['scale'], 3 * uvHeight * uvWidth);
      const rotation = this.extractOutput(outputs, ['rotation'], 4 * uvHeight * uvWidth);
      const color = this.extractOutput(outputs, ['color'], 32 * uvHeight * uvWidth);
      
      // âœ… å‡ºåŠ›æ¤œè¨¼
      console.log('[UVDecoder] Validating outputs...');
      const outputValidation = {
        localPos: this.validateArray(localPos),
        opacity: this.validateArray(opacity),
        scale: this.validateArray(scale),
        rotation: this.validateArray(rotation),
        color: this.validateArray(color)
      };
      
      console.log('[UVDecoder] Output validation:');
      console.log('  localPos:', {
        nanRatio: (outputValidation.localPos.nanRatio * 100).toFixed(1) + '%',
        range: `[${outputValidation.localPos.min.toFixed(3)}, ${outputValidation.localPos.max.toFixed(3)}]`
      });
      console.log('  opacity:', {
        nanRatio: (outputValidation.opacity.nanRatio * 100).toFixed(1) + '%',
        range: `[${outputValidation.opacity.min.toFixed(3)}, ${outputValidation.opacity.max.toFixed(3)}]`
      });
      console.log('  scale:', {
        nanRatio: (outputValidation.scale.nanRatio * 100).toFixed(1) + '%',
        range: `[${outputValidation.scale.min.toFixed(3)}, ${outputValidation.scale.max.toFixed(3)}]`
      });
      console.log('  rotation:', {
        nanRatio: (outputValidation.rotation.nanRatio * 100).toFixed(1) + '%',
        range: `[${outputValidation.rotation.min.toFixed(3)}, ${outputValidation.rotation.max.toFixed(3)}]`
      });
      
      // ã™ã¹ã¦ãŒNaNã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (outputValidation.localPos.nanRatio > 0.99) {
        throw new Error('UV Decoder output is all NaN - model inference failed');
      }
      
      // [B, C, H, W] â†’ [N, C] ã¸ã®å¤‰æ›
      const uvGaussians = this.convertToGaussians(
        new Float32Array(localPos),
        new Float32Array(opacity),
        new Float32Array(scale),
        new Float32Array(rotation),
        new Float32Array(color),
        uvWidth,
        uvHeight
      );
      
      console.log('[UVDecoder] âœ… UV Gaussians generated:', {
        count: uvGaussians.uvCount.toLocaleString(),
        hasTriangleData: uvGaussians.triangleIndices.length > 0,
        hasBarycentricCoords: uvGaussians.barycentricCoords.length > 0
      });
      
      return uvGaussians;
      
    } catch (error) {
      console.error('[UVDecoder] âŒ Generation failed:', error);
      throw error;
    }
  }
  
  /**
   * å‡ºåŠ›ãƒ†ãƒ³ã‚½ãƒ«ã‹ã‚‰é…åˆ—ã‚’æŠ½å‡º
   * ä¿®æ­£ç‰ˆ: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å¼·åŒ–
   */
  private extractOutput(
    outputs: any,
    candidateNames: string[],
    expectedLength: number
  ): number[] {
    // âœ… åˆ©ç”¨å¯èƒ½ãªå‡ºåŠ›åã‚’ç¢ºèª
    const availableNames = Object.keys(outputs);
    
    for (const name of candidateNames) {
      if (outputs[name]) {
        const data = Array.from(outputs[name].data);
        
        // âœ… ã‚µã‚¤ã‚ºæ¤œè¨¼
        if (data.length !== expectedLength) {
          console.warn(
            `[UVDecoder] âš ï¸  Output '${name}' size mismatch: ` +
            `expected ${expectedLength}, got ${data.length}`
          );
        }
        
        // âœ… å“è³ªãƒã‚§ãƒƒã‚¯ï¼ˆã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
        const sampleSize = Math.min(1000, data.length);
        const nanCount = data.slice(0, sampleSize).filter(v => isNaN(v)).length;
        
        if (nanCount > 0) {
          const nanRatio = (nanCount / sampleSize * 100).toFixed(1);
          console.warn(
            `[UVDecoder] âš ï¸  Output '${name}' contains NaN values ` +
            `(${nanRatio}% in first ${sampleSize} values)`
          );
        }
        
        return data;
      }
    }
    
    // âœ… å‡ºåŠ›ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    console.error('[UVDecoder] âŒ Output not found!');
    console.error('[UVDecoder]   Searched for:', candidateNames);
    console.error('[UVDecoder]   Available outputs:', availableNames);
    
    throw new Error(
      `Required output not found: ${candidateNames.join(', ')}. ` +
      `Available: ${availableNames.join(', ')}`
    );
  }
  
  /**
   * é…åˆ—ã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
   */
  private validateArray(data: number[]): ArrayValidation {
    let nanCount = 0;
    let infCount = 0;
    let zeroCount = 0;
    let min = Infinity;
    let max = -Infinity;
    
    for (let i = 0; i < data.length; i++) {
      const v = data[i];
      if (isNaN(v)) {
        nanCount++;
      } else if (!isFinite(v)) {
        infCount++;
      } else {
        if (v === 0) zeroCount++;
        if (v < min) min = v;
        if (v > max) max = v;
      }
    }
    
    return {
      length: data.length,
      nanCount,
      infCount,
      zeroCount,
      nanRatio: nanCount / data.length,
      zeroRatio: zeroCount / data.length,
      min: isFinite(min) ? min : 0,
      max: isFinite(max) ? max : 0
    };
  }
  
  /**
   * [B, C, H, W] å½¢å¼ã®å‡ºåŠ›ã‚’ [N, C] å½¢å¼ã®Gaussiansã«å¤‰æ›
   * ä¿®æ­£ç‰ˆ: CHWå½¢å¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ã‚’æ˜ç¤ºçš„ã«
   */
  private convertToGaussians(
    localPos: Float32Array,
    opacity: Float32Array,
    scale: Float32Array,
    rotation: Float32Array,
    color: Float32Array,
    uvWidth: number,
    uvHeight: number
  ): UVGaussianOutput {
    console.log('[UVDecoder] Converting to Gaussians...');
    
    if (!this.mapping) {
      throw new Error('Mapping not loaded');
    }
    
    const numValid = this.mapping.numValid;
    
    // âœ… ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®æ¤œè¨¼ã‚’è¿½åŠ 
    const expectedLocalPosSize = 3 * uvHeight * uvWidth;
    const expectedOpacitySize = uvHeight * uvWidth;
    const expectedScaleSize = 3 * uvHeight * uvWidth;
    const expectedRotationSize = 4 * uvHeight * uvWidth;
    const expectedColorSize = 32 * uvHeight * uvWidth;
    
    console.log('[UVDecoder] Expected vs Actual sizes:', {
      localPos: { expected: expectedLocalPosSize, actual: localPos.length },
      opacity: { expected: expectedOpacitySize, actual: opacity.length },
      scale: { expected: expectedScaleSize, actual: scale.length },
      rotation: { expected: expectedRotationSize, actual: rotation.length },
      color: { expected: expectedColorSize, actual: color.length }
    });
    
    // âœ… ã‚µã‚¤ã‚ºæ¤œè¨¼
    if (localPos.length !== expectedLocalPosSize) {
      console.error('[UVDecoder] âŒ LocalPos size mismatch!');
    }
    if (opacity.length !== expectedOpacitySize) {
      console.error('[UVDecoder] âŒ Opacity size mismatch!');
    }
    if (scale.length !== expectedScaleSize) {
      console.error('[UVDecoder] âŒ Scale size mismatch!');
    }
    if (rotation.length !== expectedRotationSize) {
      console.error('[UVDecoder] âŒ Rotation size mismatch!');
    }
    if (color.length !== expectedColorSize) {
      console.error('[UVDecoder] âŒ Color size mismatch!');
    }
    
    // å‡ºåŠ›é…åˆ—ã‚’ç¢ºä¿
    const localPositions = new Float32Array(numValid * 3);
    const opacityOut = new Float32Array(numValid);
    const scaleOut = new Float32Array(numValid * 3);
    const rotationOut = new Float32Array(numValid * 4);
    const latent32ch = new Float32Array(numValid * 32);
    const triangleIndices = new Uint32Array(numValid);
    const barycentricCoords = new Float32Array(numValid * 3);
    const uvCoords = new Float32Array(numValid * 2);
    
    // âœ… CHWå½¢å¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼
    const getChannelValue = (
      data: Float32Array,
      channel: number,
      y: number,
      x: number,
      numChannels: number
    ): number => {
      // CHWå½¢å¼: index = channel * H * W + y * W + x
      const spatialSize = uvHeight * uvWidth;
      const idx = channel * spatialSize + y * uvWidth + x;
      
      if (idx >= data.length) {
        console.warn(`[UVDecoder] Index out of bounds: ${idx} >= ${data.length}`);
        return 0;
      }
      
      const value = data[idx];
      return isNaN(value) ? 0 : value;
    };
    
    // ãƒãƒƒãƒ”ãƒ³ã‚°ã«å¾“ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
    console.log('[UVDecoder] Extracting valid pixels...');
    
    let invalidCoordCount = 0;
    
    for (let i = 0; i < numValid; i++) {
      const u = this.mapping.uvCoords[i * 2 + 0];
      const v = this.mapping.uvCoords[i * 2 + 1];
      
      // âœ… åº§æ¨™æ¤œè¨¼
      if (u >= uvWidth || v >= uvHeight) {
        if (invalidCoordCount < 10) {
          console.warn(`[UVDecoder] Invalid UV coords at ${i}: (${u}, ${v})`);
        }
        invalidCoordCount++;
        continue;
      }
      
      // Local Position (3ch)
      localPositions[i * 3 + 0] = getChannelValue(localPos, 0, v, u, 3);
      localPositions[i * 3 + 1] = getChannelValue(localPos, 1, v, u, 3);
      localPositions[i * 3 + 2] = getChannelValue(localPos, 2, v, u, 3);
      
      // Opacity (1ch)
      opacityOut[i] = getChannelValue(opacity, 0, v, u, 1);
      
      // Scale (3ch) - raw log-space values; exp() activation applied in gvrm.ts
      scaleOut[i * 3 + 0] = getChannelValue(scale, 0, v, u, 3);
      scaleOut[i * 3 + 1] = getChannelValue(scale, 1, v, u, 3);
      scaleOut[i * 3 + 2] = getChannelValue(scale, 2, v, u, 3);
      
      // Rotation (4ch)
      rotationOut[i * 4 + 0] = getChannelValue(rotation, 0, v, u, 4);
      rotationOut[i * 4 + 1] = getChannelValue(rotation, 1, v, u, 4);
      rotationOut[i * 4 + 2] = getChannelValue(rotation, 2, v, u, 4);
      rotationOut[i * 4 + 3] = getChannelValue(rotation, 3, v, u, 4);
      
      // Color/Latent (32ch)
      for (let c = 0; c < 32; c++) {
        latent32ch[i * 32 + c] = getChannelValue(color, c, v, u, 32);
      }
      
      // Triangle ãƒ‡ãƒ¼ã‚¿
      triangleIndices[i] = this.mapping.triangleIndices[i];
      barycentricCoords[i * 3 + 0] = this.mapping.barycentricCoords[i * 3 + 0];
      barycentricCoords[i * 3 + 1] = this.mapping.barycentricCoords[i * 3 + 1];
      barycentricCoords[i * 3 + 2] = this.mapping.barycentricCoords[i * 3 + 2];
      
      // UVåº§æ¨™ï¼ˆæ­£è¦åŒ–ï¼‰
      uvCoords[i * 2 + 0] = u / uvWidth;
      uvCoords[i * 2 + 1] = v / uvHeight;
    }
    
    if (invalidCoordCount > 0) {
      console.warn(`[UVDecoder] âš ï¸  Found ${invalidCoordCount} invalid UV coordinates`);
    }
    
    console.log('[UVDecoder] âœ… Conversion complete');
    
    // çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
    this.logStatistics('LocalPositions', localPositions, 3);
    this.logStatistics('Opacity', opacityOut, 1);
    this.logStatistics('Scale', scaleOut, 3);
    this.logStatistics('Rotation', rotationOut, 4);
    this.logStatistics('Latent32ch', latent32ch, 32);
    
    return {
      uvCount: numValid,
      localPositions,
      opacity: opacityOut,
      scale: scaleOut,
      rotation: rotationOut,
      latent32ch,
      triangleIndices,
      barycentricCoords,
      uvCoords
    };
  }
  
  /**
   * çµ±è¨ˆæƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
   */
  private logStatistics(name: string, data: Float32Array, channels: number): void {
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    let nanCount = 0;
    let validCount = 0;
    
    for (let i = 0; i < data.length; i++) {
      const val = data[i];
      if (isNaN(val)) {
        nanCount++;
        continue;
      }
      if (val < min) min = val;
      if (val > max) max = val;
      sum += val;
      validCount++;
    }
    
    const mean = validCount > 0 ? sum / validCount : 0;
    
    console.log(`[UVDecoder] ${name}:`, {
      shape: `[${data.length / channels}, ${channels}]`,
      min: isFinite(min) ? min.toFixed(4) : 'N/A',
      max: isFinite(max) ? max.toFixed(4) : 'N/A',
      mean: mean.toFixed(4),
      nanCount
    });
  }
}
